{
    "collab_server" : "",
    "contents" : "#################### \n#  R script for running pdog survival analysis for large plots at Sevilleta NWR\n#\n\n\n#TODO:   \n\n# plot potential weight loss/gain over time for individuals recaptured multiple times. Correlate with environmental conditions?\n\n# NOTE: trapping days 4 and 5 in 2015 (plots b and f) were experimental, and should probably not be used\n\nrm(list=ls())\n\nANA = F\nKEVIN = F\nKEVINOFFICE = F\nELIZABETHOFFICE = T\n\n###################################\n##########  SET WORKING DIRECTORY\n\nif(KEVIN) rootDir <- \"C:\\\\Users\\\\Kevin\\\\Dropbox\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\nif(KEVINOFFICE) rootDir <- \"E:\\\\Dropbox\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\nif(ANA) rootDir <- \"\"\nif(ELIZABETHOFFICE) rootDir <- \"C:\\\\Users\\\\ehunter\\\\Dropbox\\\\Nevada\\\\Sevilleta\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\n\nScriptDir <- paste(rootDir,\"Rscript\",sep=\"\")\nDataDir <- paste(rootDir,\"Data\",sep=\"\")\nFiguresDir <- paste(rootDir,\"RawFigures\",sep=\"\")\nResultsDir <- paste(rootDir,\"Results\",sep=\"\")\nBUGSDir <- paste(rootDir,\"BUGS\",sep=\"\")\n\nsetwd(DataDir)\n\ngetwd()\n\n  # setwd(BUGSDir)\n  # load(\".RData\")\n\n##################################\n##########  LOAD PACKAGES\n\nlibrary(R2WinBUGS)\nlibrary(lubridate)\nlibrary(Hmisc)\n\n##################################\n######### SET MCMC Params\n\nni = 5000\nnc <- 1\nnb <- 1000\nnt <- 1\n\nnsims <- (ni-nb)/nt\n\n\n###################################\n##########   READ IN DATA\n\n############\n#  \"pdog\" : Prairie dog capture data. \n\nsetwd(DataDir)\npdog <- read.csv(\"pdog_captures_16ha_9-12-15 AD_KTS_2016.csv\", header=TRUE)  ## KTS: updated with 2015 data and fixed a couple errors in the data\n## EAH: updated with 2016 data through June\n\n #  head(pdog)\n #  nrow(pdog)   # 3423 observations\n\nnCaptures <- nrow(pdog)\n\n############\n#  Process the capture data \n\nnames(pdog)\npdog$DATE2 <- mdy(pdog$DATE)\npdog$PLOT <- as.character(pdog$PLOT)   \npdog$PTP <- paste(pdog$SEASON,pdog$YEAR,sep=\"\")   # Primary trapping period\n\nunique(pdog$PTP)\n\npdog <- subset(pdog,!PLOT==\"G\")    # remove plot G for now (some pdogs released but not surveyed as of 2015)\n\npdog <- subset(pdog,!TRAPDAY%in%c(4,5))    # remove observations on \"experimental\" fourth and fifth capture days\n\npdog$TRAPDAY\n\n###############################\n####### DEFINE \"PERIOD\" FOR THIS STUDY\n\n# Note: some plots were trapped at different times within the same season- so trap day 1 isn't necessarily always the same date...\n\nsetwd(DataDir)\nfilename <- \"PeriodDefinition.csv\"\nsink(filename)\ncat(\"Period,Start,End,StartTrap,EndTrap,TrapDays,StartRelease,EndRelease,Median\nSUMMER2010,6/1/2010,5/28/2011,NA,NA,0,6/18/2010,8/19/2010,7/1/2010\nSUMMER2011,6/1/2011,2/28/2012,6/13/2011,6/15/2011,3,6/28/2011,9/22/2011,6/14/2011\nSPRING2012,3/1/2012,5/28/2012,4/2/2012,4/2/2012,1,4/9/2012,4/9/2012,4/2/2012\nSUMMER2012,6/1/2012,2/28/2013,6/13/2012,6/15/2012,3,6/18/2012,9/14/2012,6/14/2012\nSPRING2013,3/1/2013,5/28/2013,3/25/2013,4/5/2013,3,4/9/2013,4/9/2013,4/1/2013\nSUMMER2013,6/1/2013,2/28/2014,6/10/2013,6/22/2013,3,NA,NA,6/15/2013\nSPRING2014,3/1/2014,5/28/2014,3/17/2014,3/27/2014,3,NA,NA,3/20/2014\nSUMMER2014,6/1/2014,5/28/2015,6/9/2014,6/18/2014,3,NA,NA,6/13/2014\nSPRING2015,6/1/2015,6/30/2015,6/1/2015,6/5/2015,3,6/23/2015,6/25/2015,6/3/2015\nSUMMER2015,7/1/2015,2/28/2016,7/21/2015,7/23/2015,3,8/13/2015,8/13/2015,7/22/2015\nSPRING2016,3/1/2016,4/28/2016,4/11/2016,4/13/2016,3,NA,NA,4/12/2016\nSUMMER2016,5/1/2016,6/7/2016,6/5/2016,6/7/2016,3,NA,NA,6/6/2016\")\nsink()\n\nsetwd(DataDir)\nPeriodDef <- read.csv(filename)\n\nPeriodDef$StartDate <- mdy(PeriodDef$Start)\nPeriodDef$EndDate <- mdy(PeriodDef$End)\n#PeriodDef$Interval <- new_interval(PeriodDef$StartDate, PeriodDef$EndDate)\n\nnPeriods <- nrow(PeriodDef)\n\n  #####  DETERMINE PERIOD BETWEEN EACH PRIMARY SURVEY (periods among which population is open)\n\n ## convert to datetime object\npdate <- mdy(PeriodDef$Median)\n\n ## \ncounter=1\nintervals <- numeric(nPeriods-1)\nfor(i in 2:nPeriods){\n  intervals[counter]=as.numeric(difftime(pdate[i],pdate[i-1],units=\"days\"))/365\n  counter =counter+1\n}\n\nPeriodDef$Intervals <- c(intervals,NA)\n\n\n#######PRECIPITATION INTERVALS\n#For each period, define the precip interval that would affect that period\n#For summer periods: May-Oct\n#For spring periods: Nov-Apr\nsetwd(DataDir)\nfilename <- \"PeriodDefinition_Precip.csv\"\nsink(filename)\ncat(\"Period,Start,End\nSUMMER2010,5/1/2010,4/30/2011\nSUMMER2011,5/1/2011,10/31/2011\nSPRING2012,11/1/2011,4/30/2012\nSUMMER2012,5/1/2012,10/31/2012\nSPRING2013,11/1/2012,4/30/2013\nSUMMER2013,5/1/2013,10/31/2013\nSPRING2014,11/1/2013,4/30/2014\nSUMMER2014,5/1/2014,10/31/2014\nSPRING2015,11/1/2014,4/30/2015\nSUMMER2015,5/1/2015,10/31/2015\nSPRING2016,11/1/2015,4/30/2016\nSUMMER2016,5/1/2016,6/7/2016\")\nsink()\n\nsetwd(DataDir)\nPrecipPeriodDef <- read.csv(filename)\n\nPrecipPeriodDef$StartDate <- mdy(PrecipPeriodDef$Start)\nPrecipPeriodDef$EndDate <- mdy(PrecipPeriodDef$End)\n\n###############################\n#######  READ IN ENV CONDITIONS- PRECIP AND SOIL MOISTURE\n\nsetwd(DataDir)\n      # KTS: now we read in monthly data and summarize in R\n #precip_df <- read.csv(\"Precip data 2010-2014 - new - summarized for actual periods.csv\",header=T)   # actually includes 2015  \n #precip_df$Period <- as.character(precip_df$Period)\n #names(precip_df)\n\n\nenvCond_df <- read.csv(\"Month_sums_50 -sev 2010-2016_ppt.csv\",header=T) #Now includes 2016 through May\nnames(envCond_df)\n\n  ## add a \"Date\" field\ntemp <- paste(envCond_df$mon,1,envCond_df$year,sep=\"/\")\nenvCond_df$Date <- mdy(temp)\n\n#########\n#  summarize environmental conditions by period\n##JUST PRECIP and SOILH2O\nenvCond_df <- envCond_df[,c(1,2,6,12,13)]\nenvCondNames <- names(envCond_df)\n\nnewline <- envCond_df[1,-which(envCondNames%in%c(\"Date\",\"mon\"))]\nnames(newline)[1] <- \"Period\"\n\nenvCond <- newline[-1,]\n\np=1\nfor(p in 1:nPeriods){\n  ndx <- which((envCond_df$Date>=PrecipPeriodDef$StartDate[p])&(envCond_df$Date<PrecipPeriodDef$EndDate[p]))\n  temp <- newline\n  temp[1,1] <- as.character(PrecipPeriodDef$Period[p])\n  i=2\n  for(i in 2:ncol(temp)){\n    colname <- names(temp)[i]\n    ndx2 <- which(names(envCond_df)==colname)\n    temp[1,i] <- mean(envCond_df[ndx,ndx2])\n  }\n  envCond <- rbind(envCond,temp)\n}\n\nprecip <- envCond$ppt\n\n       ## and soil moisture data...\n\nsoilH2O <- envCond$sH2O\n\n\n###################################\n   ####        DEVELOP UNIQUE ID VAR (\"indiv\")\n   ####  KTS 11/17/15: made this more thorough- now record number of tags and type of tags for each individual\n\n\npdog$TagR <- as.character(pdog$RIGHTTAG)      \npdog$TagL <- as.character(pdog$LEFTTAG)\npdog$PIT.TAG <- as.character(pdog$PITTAG)\n\nndx <- which(pdog$TagR==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$TagR[ndx] <- NA \nndx <- which(pdog$TagL==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$TagL[ndx] <- NA \nndx <- which(pdog$PIT.TAG==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$PIT.TAG[ndx] <- NA \n\n\n### new strategy: \n       # first make a list with all single tags \n       # then loop through this vector\n           # IF this ID was ever observed on the same individual as another ID later in the list, \n           # THEN remove that other ID from the list and associate it with the ID in question \n             \n### NOTE: this takes a long time, totally inefficient, but whatever! \n\nuniqueR <- unique(pdog$TagR)\nuniqueR <- uniqueR[!is.na(uniqueR)]\nuniqueL <- unique(pdog$TagL)\nuniqueL <- uniqueL[!is.na(uniqueL)]\nuniquePIT <- unique(pdog$PIT.TAG)\nuniquePIT <- uniquePIT[!is.na(uniquePIT)]\n\nfreeIDs <- c(uniqueL,uniqueR,uniquePIT)  # all unique ID tags\nusedIDs <- numeric(0)\n\nindivList <- list()\nIDarray <- with(pdog,cbind(TagL,TagR,PIT.TAG) )\n\ncounter=1\nt=1\nfor(t in 1:length(freeIDs)){      #loop through all ID tags\n  thisID <- freeIDs[t]\n  if(!thisID%in%usedIDs){   # if this tag hasn't been used before\n    indivList[[counter]] <- thisID    # this must be a new individual \n    usedIDs <- c(usedIDs,thisID)\n    temp <- IDarray[apply(IDarray,1,function(t) thisID%in%t),]   # observations involving this tag\n    temp <- unique(as.vector(temp))\n    temp <- temp[!is.na(temp)]\n    temp <- temp[temp!=thisID]\n    if(length(temp)>0){\n      indivList[[counter]] <- c(indivList[[counter]],temp)  # add all other associated IDs\n      usedIDs <- c(usedIDs,temp)\n\n      while(length(temp)>0){  # go through the other IDs- make sure that these IDs are not associated with other IDs\n        thisID2 <- temp[1]     #take the first element of temp\n        temp2 <- IDarray[apply(IDarray,1,function(t) thisID2%in%t),]\n        temp2 <- unique(as.vector(temp2))\n        temp2 <- temp2[!is.na(temp2)]\n        temp2 <- temp2[!temp2%in%usedIDs]\n        indivList[[counter]] <- c(indivList[[counter]],temp2)    # add any new ID tags associated with this individual\n        usedIDs <- c(usedIDs,temp2)\n        temp<-temp[-1]\n      }  \n    }  \n    counter <- counter + 1 \n  }\n}\n\n\n #####  Good- this seems to work...\n\n#######################################\n### NOW: make a new \"indiv\" field... \n\n### NOTE: again, this takes a long time, but F#@# it :) \n\npdog$indiv <- 0\n\nnan <- length(indivList)\n\nnrow(IDarray)     # temp\nnrow(pdog)\n\n\nerrcheck <- numeric(0)   # which individual IDs, if any, are associated with multiple individuals (error check)\nnoobsndx <- numeric(0)   # which observations are associated with no ID at all??\n\ni=32\nfor(i in 1:nrow(pdog)){\n  tempID <- IDarray[i,]\n  tempID <- unique(as.vector(tempID))\n  tempID <- tempID[!is.na(tempID)]\n  tempID <- tempID[1]  # just pick the first of the IDs...\n\n  temp2 <- (1:nan)[sapply(indivList,function(t) tempID%in%t)]   # which individual is this??\n\n  if(length(temp2)>1) errcheck <- c(errcheck,i)   # if this corresponds to more than one individual, there is a problem!!\n  if(length(temp2)==0) noobsndx <- c(noobsndx,i)\n  pdog$indiv[i] <- ifelse(length(temp2)==1, temp2, NA)  \n}\n\nerrcheck   # Good- no ambiguous identifications\n\nnoobsndx    # 9 captures with no IDs \n\npdog[noobsndx,]   # checks out\n\n##### NOW: remove any individuals that had no ID\n\npdog <- pdog[-noobsndx,]\n\npdog$indiv    # looks OK\n\n\n#### NOW: generate capture histories as a list- one dataframe of observations per individual (CHList)\n\nuniqueNames <- unique(pdog$indiv)\nnan <- length(uniqueNames)\ni=1122\nCHList <- list()   \nfor(i in 1:nan){        # remember to sort by date\n  eval(parse(text=sprintf(\"CHList$indiv%s <- subset(pdog,indiv==uniqueNames[i])\",uniqueNames[i])))\n  eval(parse(text=sprintf(\"CHList$indiv%s <- CHList$indiv%s[order(CHList$indiv%s$DATE2),]\",uniqueNames[i],uniqueNames[i],uniqueNames[i])))\n}\n\n  \n####################################\n##########  SUMMARY DATA (global: suffix \"G\")\n\nnames(pdog)\n\nnobsG <- nrow(pdog)       # 3272 observations\n\nnindG <- length(unique(pdog$indiv))     # 2505 individuals \n\nrealindG <- unique(pdog$indiv)  \n\nnyearsG <- length(unique(pdog$YEAR))     # 6 years\n\nrealyearsG <- sort(unique(pdog$YEAR))\n\nnperiodsG <- length(unique(pdog$PTP))    # 10 primary trapping periods\n\nrealperiodsG <- unique(pdog$PTP)\n\nnplotsG <- length(unique(pdog$PLOT))     # 3 plots\n\nrealplotsG <- as.character(unique(pdog$PLOT)) \n\nndatesG <- length(unique(pdog$DATE))     # 73 survey occasions / release events\n\nrealsurveydatesG <- format(sort(unique(pdog$DATE2[which(!is.na(pdog$TRAPDAY))])),format=\"%m/%d/%Y\")\n\nnsurveysG <- length(realsurveydatesG)   # 38 trapping surveys\n\nrealreleasedatesG <- format(sort(unique(pdog$DATE2[which(is.na(pdog$TRAPDAY))])),format=\"%m/%d/%Y\")\n\nnreleasesG <- length(realreleasedatesG)   # 31 release dates\n\nrealdatesG <- format(sort(unique(pdog$DATE2)),format=\"%m/%d/%Y\")\n\nrealperiodyearsG <- as.numeric(na.omit(as.numeric(unlist(strsplit(unlist(realperiodsG), \"[^0-9]+\")))))\n\n   # look at num caps each year by plot\n\ntable(pdog$PLOT,pdog$YEAR)   \n\npdog$PTP2 <- factor(pdog$PTP,levels=realperiodsG)   # make the periods are ordered properly\n\ncaptures <- subset(pdog,!RECAPTYPE==\"RELEASE\")  \n\ntable(captures$PLOT,captures$YEAR)\n\nreleases <- subset(pdog,RECAPTYPE==\"RELEASE\")\n\nsumReleases <- table(releases$PLOT,releases$PTP2)\n\n\nsetwd(DataDir)\nsave(nobsG,nindG,realperiodyearsG,realdatesG,nreleasesG,realreleasedatesG,nsurveysG,realsurveydatesG,ndatesG,realplotsG,nplotsG,\n     realperiodsG,nperiodsG,realyearsG,nyearsG,realindG,sumReleases,precip,soilH2O,\n     nsims,file=\"GlobalParams.RData\")\n\n#####################################\n##############  Verify survey effort across sites\n\nfor(t in 1:nyearsG){\n  ndx <- which(pdog$YEAR==realyearsG[t])\n  print(table(pdog$PLOT[ndx]))\n}\n\n    ### there was survey effort conducted at plots B and C every year. Then at F as soon as it came online\n\n\n###############################\n############   SUMMARIZE RELEASES  \n\n ## NOTE: TRAPDAY signifies real trapping occasions/suboccasions. When TRAPDAY is NA, is was a release occasion\n\n\nnames(pdog)\ntable(pdog$PTP,pdog$TRAPDAY)   # no trapping in 2010- just releases\n\n\ntable(pdog$RELEASE)    # 2315 pdogs released. 957 pdogs captured\n\n        ## KTS: note: do we have recruitment information in this data set? That is, individuals recruited into\n               # the population are those that were not released! \n\n\n################################\n############## SUMMARIZE DATA FOR WINBUGS\n\nnames(pdog)\nhead(pdog)\n\n   ## loop through data and summarize the data for each dimension of interest\n\nns <- nPeriods\nnss <- array(0,dim=c(nPeriods))   # number of surveys (suboccasions)\nnan <- nindG   # number of animals \nnames <- realindG  #  list()\n\ny=4\nfor(y in 1:nPeriods){\n  ndx <- which((pdog$PTP==realperiodsG[y])&(!is.na(pdog$TRAPDAY)))     \n  nss[y] <- length(unique(pdog$TRAPDAY[ndx]))\n}\nnss[1] <- 1    # allow the first season to have a dummy trapping event (these are all releases... )\n\nmaxnan <- max(nan)\nmaxnss <- max(nss)      # max of 3 suboccasions... \n\n\n\n##########################\n#######       MAKE CAPTURE HISTORY DATA FOR WINBUGS\n\n      # note: if possible, capture histories should include the releases/initial captures... #KTS: Why didn't they before????\n\n\n######## INITIALIZE DATA ARRAYS\n\ncaphist <- array(0,dim=c(maxnan,nperiodsG,maxnss))     # Master 3-D capture history array\ncaphist_2D <- array(0,dim=c(maxnan,nperiodsG))\nNMarks <- array(NA,dim=c(maxnan,nperiodsG))     # choose the min number of marks in each PTP\nLeftEarTag <- array(NA,dim=c(maxnan,nperiodsG))\nRightEarTag <- array(NA,dim=c(maxnan,nperiodsG))\n\nReleased <- array(0,dim=c(maxnan,nperiodsG))    # if release happens after trapping, code as \"1\" in final suboccasion. If released before trapping, put \"1\" in initial suboccasion.\nSpringRelease <- array(0,dim=c(maxnan,nperiodsG)) # NOTE: actually, releases ALWAYS happened after the final trapping event (this is good!)\n #Juvenile <- array(0,dim=c(maxnan,nperiodsG))\nPITTag <- array(0,dim=c(maxnan,nperiodsG))     # if it has a pit tag, can't lose tags\nAddLeftTag <- array(0,dim=c(maxnan,nperiodsG))\nAddRightTag <- array(0,dim=c(maxnan,nperiodsG)) \n\nfirsts <- numeric(maxnan)\nfirst2 <- numeric(maxnan)\n\naddTagNdx <- character(0)   # observations where tag was added...\n  \n\nind=285#2510#2327#285#1122#1#\nfor(ind in 1:nan){\n  df <- CHList[[ind]] \n              # make sure to sort by date!\n  df <- df[order(df$DATE2),]\n  tags <- with(df,cbind(TagL,TagR,PIT.TAG))\n                                                         ### ensure that once it has a pit tag, it always has that pit tag... \n  pitpresent <- !is.na(tags[,3])   # is there a PIT tag?\n  firstpit <- ifelse(any(pitpresent),which(pitpresent)[1],NA)\n  if(!is.na(firstpit)) tags[min(nrow(df),(firstpit+1)):nrow(df),3] <- tags[firstpit,3]    # make sure that pit tag is not lost... since pit tags cant be lost in this model\n\n  df$nMarks <-  apply(tags,1,function(t) length(t[!is.na(t)])) \n  \n  obs <- 1\n  for(obs in 1:nrow(df)){   # loop through by observation.. \n    thisObs <- df[obs,]\n    thisTags <- tags[obs,]\n    thisPeriod <- which(PeriodDef$Period==thisObs$PTP)\n    thisSub <- ifelse(!is.na(thisObs$TRAPDAY),thisObs$TRAPDAY,max(nss[thisPeriod]))    # if it's just released, put it at the last suboccasion\n\n    if(obs==1){    # if this is the first capture\n      firsts[ind] <- thisPeriod            # record period of first capture\n      first2[ind] <- thisSub\n    }\n\n    if((!is.na(firstpit))&(obs==firstpit)){  # if has pit and this is the first observation with pit tag\n      PITTag[ind,thisPeriod:nPeriods] <- 1      # then we assume this individual has a pit tag forever, as long as it is alive. can't lose this mark\n    }\n      \n    caphist[ind,thisPeriod,thisSub] <- 1                              # captured this suboccasion?\n    caphist_2D[ind,thisPeriod] <- 1                                   # capture this period? (standard 2D capture history)\n\n    if(thisObs$RECAPTYPE==\"RELEASE\"){\n      Released[ind,thisPeriod] <- 1    # released this period?   \n\t    if(month(thisObs$DATE2)%in%c(4,5,6)) SpringRelease[ind,thisPeriod] <- 1                             # is it a spring release?\n\t  }\n\n    NMarks[ind,thisPeriod] <- df$nMarks[obs]  # number of tags observed on this individual\n    LeftEarTag[ind,thisPeriod] <- ifelse(!is.na(tags[,\"TagL\"][obs]),1,0) \n    RightEarTag[ind,thisPeriod] <- ifelse(!is.na(tags[,\"TagR\"][obs]),1,0)   \n    tagsadded <- (!is.na(thisTags))&((!thisTags==tags[max(1,obs-1),])|(is.na(tags[max(1,obs-1),])))\n    AddLeftTag[ind,thisPeriod] <- ifelse(tagsadded[1],1,0)\n    AddRightTag[ind,thisPeriod] <- ifelse(tagsadded[2],1,0)\n    if(any(tagsadded)) addTagNdx <- c(addTagNdx,sprintf(\"ind%s_obs%s\",ind,obs))\n  }  \n}\n\n   # make sure once indiv has PIT, it is not lost... \ntail(PITTag,500)\n\n\n###############################\n############ MAKE SITE VARIABLE  (history of plots each individual was captured on) (check: did any move from plot to plot?)\n\n\nplothist <- array(NA,dim=c(maxnan,nperiodsG)) \ni=1\n\nfactorplot <- as.factor(pdog$PLOT) \nfor(i in 1:nan){\n  p=1\n  for(p in 1:nperiodsG){\n      ndx <- which((pdog$PTP==realperiodsG[p])&\n                   (pdog$indiv==realindG[i]))\n      if(length(ndx)>0) plothist[i,p] <- as.numeric(factorplot[ndx[1]]) \n  }\n}\n\nhead(plothist,500)\ntail(plothist,500)\n\n   ## interesting- several pdogs actually do switch plots...\n   ## Actually- not true- several ear tags are doubles! notably, 321-324 were re-used in 2015\n\nplothist2 <- apply(plothist,c(1,2),function(t) ifelse(is.na(t),0,t))\ntemp <- apply(plothist2,1,function(t) length(unique(t)))\n\nlength(which(temp==3))  # total of 5 pdogs moved from one plot to another.\nrealindG[which(temp==3)]   # the following individuals \"moved\": 563  646  730 2109 2214\n\nCHList$indiv563\nCHList$indiv646\nCHList$indiv1507    # one individual moved twice!!\n\n# NOTE: KTS: fixed the obvious errors here with duplicate tags... \n# NOTE: two individuals released in Plot \"f\" moved to different plots, where they were subsequently recaptured. There is little evidence of any other such movements\n\n\n############### MAKE DUMMY MATRIX FOR EACH PLOT\n\nplothist3 <- plothist2*(1-Released)     # only those individuals that were captured\n\nisPlotB <- apply(plothist3,c(1,2),function(t) ifelse(t==1,1,0) )\nisPlotD <- apply(plothist3,c(1,2),function(t) ifelse(t==2,1,0) )\nisPlotF <- apply(plothist3,c(1,2),function(t) ifelse(t==3,1,0) )\n\nhead(isPlotB,100)\n\n############################\n##    MAKE COHORT VARIABLE\n\n       ### loop through years. all individuals released on a given year get assigned a unique cohort... \n       ### need an \"is.rel\" variable also. Should we model a release effect?\n\ncohort <- numeric(nan)\nfor(i in 1:nan){\n  for(p in 1:length(realperiodsG)){\n    ndx <- which((pdog$PTP==realperiodsG[p])&\n                 (pdog$RELEASE==\"Y\")&\n                 (pdog$indiv==realindG[i]))\n    if(length(ndx)>0) cohort[i] <- p  \n  }\n}    \nndx <- which(cohort==0)           # NOTE: The last cohort represents native born individuals\ncohort[ndx] <- max(cohort)+1\nncohorts <- max(cohort)\n\n##############################\n##        STORE SEX AND AGE FOR EACH INDIVIDUAL\n\nisMale <- numeric(nan)\n\nfor(i in 1:nan){\n  ndx <- which(pdog$indiv==names[i])\n  sexvec <- pdog$SEX[ndx]\n  sexvec <- sexvec[which(!is.na(sexvec))]\n  sex <- as.character(sexvec[length(sexvec)])    # final determined sex is the true sex...\n  isMale[i] <- ifelse(length(sex>0),ifelse(sex==\"M\",1,0),0)\n   #  pdogT[ndx,]\n}\n\n \nisJuv  <- array(1,dim=c(nan,nperiodsG))\n\ni=1   #363\np=firsts[i]\nfor(i in 1:nan){\n  firstyear <- realperiodyearsG[firsts[i]]\n  for(p in firsts[i]:nperiodsG){\n    if(realperiodyearsG[p]==firstyear){   # if within the first year of capture\n      ndx <- which((pdog$indiv==names[i]) &\n                 (pdog$YEAR==firstyear) )\n      if(length(ndx)>0){\n        tempage <- as.character(pdog$AGE[ndx])[1]\n        isJuv[i,p] <- ifelse(tempage==\"J\",1,0)\n      }\n    } else{\n      isJuv[i,p] <- 0\n    } \n  }\n}\n\nisJuv <- apply(isJuv,c(1,2),function(t) ifelse(is.na(t),0,t))\n\ntail(isJuv,500)\n\n\n##################\n# determine if the pdog was from taos (hoarded individuals)\n\nhoarded <- numeric(nan)\n\ni=1\nfor(i in 1:nan){\n  thisch <- CHList[[i]]\n  thisrel <- which(thisch$RELEASE==\"Y\")\n  if(length(thisrel)>0){\n    temp <- grep(\"aos\",thisch$SITE)\n    if(length(temp)>0) hoarded[i] <- 1\n  }  \n}\n\nhoardndx <- which(hoarded==1)\n\nCHList[[hoardndx[1]]]\n\n##############################\n#######   WINBUGS CODE\n\n\n######################\n#     SET BUGS OR JAGS DIRECTORY\n#####################\n\nif(KEVIN){\n  bugs.directory=\"C:\\\\Users\\\\Kevin\\\\Documents\\\\Employment\\\\ESF\\\\Bog Turtle\\\\DATA\\\\software\\\\BUGS\\\\WinBUGS14\"\n    #if(HRAPC) bugs.directory= \"C:\\\\Users\\\\Kevin\\\\Desktop\\\\Kevin\\\\WinBUGS14\"\n}\n\nif(KEVINOFFICE){\n  bugs.directory=\"C:\\\\WinBUGS\\\\winbugs14\\\\WinBUGS14\"\n  #if(HRAPC) bugs.directory= \"C:\\\\Users\\\\Kevin\\\\Desktop\\\\Kevin\\\\WinBUGS14\"\n}\n\nif(ELIZABETHOFFICE){\n  bugs.directory= \"C:\\\\Users\\\\eahunter\\\\Documents\\\\WinBUGS14\\\\\"\n}\n\nworking.directory= BUGSDir   \nsetwd(working.directory)\n\n################################\n#      # WRITE BUGS OR JAGS MODEL TO FILE\n################################\n\nfilename <- \"SevPDModel_20160617_oneMonthRelEff\"  \n\nmodel.file <- paste(filename,\".bug\",sep=\"\")\n\n\nsink(model.file)\n\ncat(\"\n    \n# Cormack Jolly Seber model, robust design \n#  K Shoemaker Nov 2015  \n\n    ##########################################\n    #  BEGIN MODEL\n    model {\n    \n    ###############################################\n    #  SET PRIORS\n    \n    #####################\n    # survival terms \n    \n    phi0 ~ dunif(0.01,0.99)           # mean survival rate\n    logit.phi <- log(phi0/(1-phi0))   # transform to logit scale... \n    precipEff ~ dunif(-2,2)           # beta term for effect of (normalized) precip on survival  \n    soilEff ~ dunif(-2,2)             # beta term for effect of (normalized) soil moisture on survival\n    maleEff ~ dunif(-2,2)             # beta term for sex effect on survival   \n    juvEff ~ dunif(-2,2)              # beta term for juvenile/age effect on survival\n    relEff ~ dunif(-28,0.5) #-4            # beta term for release effect on survival# NOTE: effect lasts for only one month!\n    #juvRelEff ~ dunif(-4,4)           # beta term for juvenile/release interaction \n    springRelEff ~ dunif(-8,8)        # beta term for spring release effect        \n    hoardEff ~ dunif(-2,2)            # beta term for effect of hoarded individuals (taos 2012) on survival\n    \n \n    ##########################\n    # capture probability terms    \n\n    p0 ~ dunif(0.01,0.75)           # mean probability of capture per secondary trapping occasion    \n    logit.p <- log(p0/(1-p0))       # transform to logit scale\n\n     sd.ind   ~ dunif(0.1,1)         #  random effect of individual on capture probability (due to overlap of home range)  # KTS: added this back\n     prec.ind <- 1/pow(sd.ind,2) \n\n    for(i in 1:nan){\n      indeff[i] ~ dnorm(0,prec.ind)   # logit-normal random intercept (KTS: added this back in when I removed the temp migration term)\n    }\n\n    ##################\n    # tag loss terms (KTS: added 11/16/15) \n             # note: we assume that PIT tags are never lost\n             #  todo: account for loss of both tags in the same time interval??????\n\n    tagRetentionRate ~ dunif(0.4,0.99)         # annual rate of ear tag retention (per tag) \n\n    for(i in 1:nan){\n      tagged[i,first[i]] <- 1                        # no chance of losing any tags at release \n      for(t in (first[i]+1):ns){\n        pHasLeftEarTag[i,t] <- (1-leftTagAdded[i,t])*(hasLeftEarTag[i,t-1] * pow(tagRetentionRate,interval[t-1])) + leftTagAdded[i,t]     # probability of retaining a tag in the interval since last survey (to lose a tag, it had to have at least one!).  NOTE: assumes only one tag can be lost each period\n        hasLeftEarTag[i,t] ~ dbern(pHasLeftEarTag[i,t])              # latent state/DATA NODE- Does it have a left ear tag? This is sometimes observed.     \n        pHasRightEarTag[i,t] <- (1-rightTagAdded[i,t])*(hasRightEarTag[i,t-1] * pow(tagRetentionRate,interval[t-1])) + rightTagAdded[i,t]     # probability of retaining a tag in the interval since last survey (to lose a tag, it had to have at least one!).  NOTE: assumes only one tag can be lost each period\n        hasRightEarTag[i,t] ~ dbern(pHasRightEarTag[i,t])              # latent state/DATA NODE- does it have a right ear tag? This is sometimes observed.\n        nTags[i,t] <- hasLeftEarTag[i,t] + hasRightEarTag[i,t] + PITTag[i,t]            \n        tagged[i,t] <- step(nTags[i,t]-1)            # latent state: is the individual lost from the population??\n      }\n    }   \n   \n    #####################################################\n    #  SET OVERALL PROCESS MODEL\n    \n    \n    #  SURVIVAL MODEL (no release effect)\n    \n    for(i in 1:nan){\n      for(t in 1:(ns-1)){\n        mu.phi[i,t]   <- logit.phi + precipEff*precip[t] + soilEff*soil[t] +        \n                               juvEff*isJuv[i,t] + maleEff*isMale[i] +    ### + relEff*isRel[i,t] +    ## KTS: removed release effects here\n                               hoardEff*isHoard[i] #### + juvRelEff*isJuv[i,t]*isRel[i,t] + springRelEff*springRel[i,t]  # function for survival rate      \n        phi[i,t]      <- 1/(1+exp(-1*mu.phi[i,t]))                     \n      }\n    }\n    \n\n    #  SURVIVAL MODEL (with release effect)  ## NOTE: this effect is annualized, to make sure everything is on a common currency.\n                                                       ## HOWEVER, the effect only ever lasts for one month. \n    \n    for(i in 1:nan){\n      for(t in 1:(ns-1)){\n        mu.phiRel[i,t]   <- logit.phi +\t\t## precipEff*precip[t] + soilEff*soil[t] +   #No precip effect for release     \n        juvEff*isJuv[i,t] + maleEff*isMale[i] + relEff*isRel[i,t] +    # with release-year effects \n        hoardEff*isHoard[i]  + springRelEff*springRel[i,t]       #Removed + juvRelEff*isJuv[i,t]*isRel[i,t]  - confounded w/ spring\n        phiRel[i,t]      <- 1/(1+exp(-1*mu.phiRel[i,t]))                     \n      }\n    }\n    \n    ########## Latent variable: living or dead \n    \n    for(i in 1:nan){\n      alive[i,first[i]] ~ dbern(1)   # at first capture, the animal is alive\n    \n      for(t in (first[i]+1):ns){\n        transition_norel[i,t] <- pow(phi[i,t-1],interval[t-1])   \n        transition_rel[i,t] <- pow(phiRel[i,t-1],(1/12)) * pow(phi[i,t-1],(interval[t-1]-(1/12)))  # release effect lasts for only one month...\n        transition[i,t] <- isRel[i,t-1]*transition_rel[i,t] + (1-isRel[i,t-1])*transition_norel[i,t]\n        mualive[i,t] <- alive[i,(t-1)] * transition[i,t]  # probability of each ind being alive, all subsequent periods\n        alive[i,t] ~ dbern(mualive[i,t])        # latent variable- is it still alive?\n      }\n    }\n    \n    ####################################\n    #  OBSERVATION MODEL   (actual data likelihood)\n\n                        # use the year/season of first capture to help refine p estimates. Assume no tags fall off within a single 3-day trapping session\n    for(i in 1:nan){\n      for(j in (first2[i]+1):nss[first[i]]){\n        mu.p[i,first[i],j] <- logit.p + indeff[i]   # KTS: added individual effect back\n        p[i,first[i],j] <- (1/(1+exp(-1*mu.p[i,first[i],j])))   #* surveyed[first[i],j]\n        muy[i,first[i],j] <- alive[i,first[i]]*p[i,first[i],j] \n        y[i,first[i],j] ~ dbern(muy[i,first[i],j])    #  DATA NODE   likelihood of observed data... \n      }\n    }\n    \n    for(i in 1:nan) { \n      for(t in (first[i]+1):ns) { \n        for(j in 1:nss[t]){                \n          mu.p[i,t,j]  <- logit.p  + indeff[i]            #  logit probability of capture for this individual   [[add term for number of grids deployed]]  \n          p[i,t,j]     <- (1/(1+exp(-1*mu.p[i,t,j]))) #* surveyed[t,j]                                   #  convert back to probability scale\n          muy[i,t,j]   <- alive[i,t]*tagged[i,t]*p[i,t,j] # *onsite[i,t]                    # if it's alive and tagged, then it's seen with prob. p.  \n          y[i,t,j] ~ dbern(muy[i,t,j])                 #  DATA NODE   likelihood of observed data...  \n        }\n      }       \n    }\t\t\n    \n    #################################################\n    #  ADDITIONAL CALCULATIONS\n    \n    #################\n    ####  CALCULATE ABUNDANCE USING HORVITZ-THOMPSON ESTIMATOR....\n    # note: only applies to sampled areas (grids)\n    # account for # grids deployed\n    # note: should be per hectare.\n     \n    for(i in 1:nan){\n      for(t in 2:ns){\n        mu.p2[i,t,1] <- logit.p + indeff[i]\n        p2[i,t,1] <- 1/(1+exp(-1*mu.p2[i,t,1]))   # back to prob. scale\n        pncap[i,t,1] <- 1-p2[i,t,1]        # pncap refers to the probability of not capturing for entire 3-day interval\n        for(j in 2:nss[t]){\n          mu.p2[i,t,j] <- logit.p + indeff[i]\n          p2[i,t,j] <- 1/(1+exp(-1*mu.p2[i,t,j]))   # back to prob. scale\n          pncap[i,t,j] <- pncap[i,t,j-1]*(1-p2[i,t,j])\n        }\n        pcap[i,t] <- 1-pncap[i,t,nss[t]]     # pcap refers to the prob of being captured at least once for entire 3-day period\n        invpcap[i,t] <- 1/pcap[i,t]    # for H-T estimator\n      } \n    }\n\n\n    for(t in 2:ns){\n      Ntot[t] <- inprod(invpcap[1:nan,t],ch2D[1:nan,t])     #nan2[t] / pcap[t]   # estimate of total abundance within sampled region... \n      #N[t] <- N[t]/nGrids[t]    # convert to abundance per ha (assuming 4 grids were always deployed...)\n      N_plotB[t] <- inprod(invpcap[1:nan,t],isB[1:nan,t])\n      N_plotD[t] <- inprod(invpcap[1:nan,t],isD[1:nan,t])\n      N_plotF[t] <- inprod(invpcap[1:nan,t],isF[1:nan,t])\n      \n    }\n    \n    #################\n    ##### CALCULATE SURVIVAL RATE OVER TIME...\n    \n    # store the survival rate for each year\n    for(t in 1:(ns-1)){\n      femphi2[t] <- logit.phi + precipEff*precip[t] + soilEff*soil[t]   # + predEff*badyr[t]\n      femphi[t] <- 1/(1+exp(-1*femphi2[t]))\n      malephi2[t] <- logit.phi + precipEff*precip[t] + soilEff*soil[t] +  maleEff \n      malephi[t] <- 1/(1+exp(-1*malephi2[t]))\n      juvphi2[t] <- logit.phi + precipEff*precip[t] + soilEff*soil[t] + juvEff\n      juvphi[t] <- 1/(1+exp(-1*juvphi2[t]))\n      #reladultphi2[t] <- logit.phi + precipEff*precip[t] + soilEff*soil[t] + relEff\n      #reladultphi[t] <- 1/(1+exp(-1*reladultphi2[t]))\n    } \n\n    ### determine average 1-month survival of released individuals...\n\n    falljuvrelsurv_mo <-  pow(1/(1+exp(-1*(logit.phi + relEff + juvEff))),(1/12))  #Removed + juvRelEff \n    falladrelsurv_mo <-  pow(1/(1+exp(-1*(logit.phi + relEff))),(1/12))\n    springjuvrelsurv_mo <-  pow(1/(1+exp(-1*(logit.phi + relEff + juvEff + springRelEff))),(1/12))  #Removed + juvRelEff \n    springadrelsurv_mo <-  pow(1/(1+exp(-1*(logit.phi + relEff + springRelEff))),(1/12))        \n    \n    ##########################################\n    }  # END MODEL\n    ##########################################\n\n\n    \n\n\n    \",fill = TRUE)\n\nsink()                   ## Writes BUGS code to the appropriate file\n\n\n\n######################################\n########  summarize total individuals captured in trap surveys (per grid...)\n\nndx <- which((pdog$RELEASE==\"Y\")) \npdogTRAPPED <- pdog[-ndx,] \n\n     # summarize the number captured in each year\n\ntemp <- table(pdogTRAPPED$PTP)\nnamesP <- names(temp)\n\nndx<-match(realperiodsG,namesP)\n\nnanTRAPPED <- as.numeric(temp)[ndx]\nnanTRAPPED[which(is.na(nanTRAPPED))] <- 0\n\ntable(pdogTRAPPED$PLOT,pdogTRAPPED$PTP)[,ndx]\n\nnGrids <- c(0,2,2,2,3,3,3,3,3,3)\n\nnanTRAPPED_perGrid <- nanTRAPPED/nGrids\n\nnanTRAPPED_perGrid[1] <- 0\n \n########################################\n########  START BUILDING DATA FOR WINBUGS\n\n\n     ########################################\n     #########    standardize covariates\n\nmeanlogprecip <- mean(log(precip))             # standardize precip variable\nsdlogprecip <- sd(log(precip))\nprecip_std <- (log(precip)-meanlogprecip)/sdlogprecip\n\nmeanlogsoil <- mean(log(soilH2O))             # standardize soil variable\nsdlogsoil <- sd(log(soilH2O))\nsoil_std <- (log(soilH2O)-meanlogsoil)/sdlogsoil\n\nData <- list(nan = nan, \n             #nan2 = nanTRAPPED_perGrid,\n             ns = nperiodsG,\n             #nGrids = nGrids,\n             #ncohorts = ncohorts,\n             #cohort = cohort,\n             soil = as.vector(soil_std),\n             nss = as.vector(nss),\n             first = as.vector(firsts),\n             first2 = as.vector(first2),\n             interval = as.vector(intervals),  \n             precip=as.vector(precip_std),\n             y = caphist,\n             ch2D = caphist_2D,\n             isB = isPlotB,\n             isD = isPlotD,\n             isF = isPlotF,\n             isMale = isMale,\n             isJuv = isJuv,\n             isRel = Released,\n             springRel = SpringRelease,\n             PITTag = PITTag,\n             leftTagAdded = AddLeftTag,\n             rightTagAdded = AddRightTag,\n             hasLeftEarTag = LeftEarTag,\n             hasRightEarTag = RightEarTag,\n             isHoard = hoarded      \n)\n\nZ <- array(1,dim=c(nan,nperiodsG))\n\nInits <- function() list(       #  initial values for all parameters for BUGS MCMC routine\n                phi0 = runif(1,.4,.6),\n                precipEff = runif(1,0.5,1),\n                #predEff = runif(1,-2,-1),\n                soilEff = runif(1,-2,0),\n                maleEff = runif(1,-1,0),\n                juvEff = runif(1,-0.5,0.5),\n                relEff = runif(1,-3.5,-2.5),\n                #juvRelEff = runif(1,-0.5,0.5),\n                springRelEff = runif(1,-0.5,0.5),\n                #sd.ind = runif(1,0.2,0.3),\n\t\t            p0 = runif(1,.2,.3),\n                tagRetentionRate = runif(1,0.6,0.7),\n                #pbadyr = runif(1,0.4,0.6),\n                #gamma.prime = runif(1,0.4,0.6),\n                #gamma.dprime = runif(1,0.4,0.6),\n                #indeff = runif(nan,-0.1,0.1),\n                #badyr3 = rep(1,times=nperiodsG),\n                #onsite = Z,\n                alive = Z               \n\t\t)  \n\nPar <- c(          #   parameters to save the posterior samples for\n         #\"N\",     # H-T estimate of abundance        \n         \"phi0\",      # mean probability of survival\n         #\"phi\",      # actual estimate of survival for each year\n\t   #\"badyr\",\n         #\"pbadyr\",  # probability that a sampling period has low survival (due to predation?)\n         \"precipEff\",   # effect of precip on survival\n         \"soilEff\",\n         \"hoardEff\",\n         \"maleEff\",\n         #\"predEff\",     # reduction in survival rate in a bad year\n         #\"cohortEff\",\n         \"juvEff\",\n         \"relEff\",\n         #\"juvRelEff\",\n         \"springRelEff\",\n         \"tagRetentionRate\",\n         #\"sd.ind\",\n         \"p0\",            # mean nightly prob. of capture\n         #\"gamma.prime\",    # probability of staying off site\n         #\"gamma.dprime\",     # probability of leaving??\n         \"femphi\",\n         \"malephi\",\n         \"juvphi\",\n         #\"reladultphi\",\n\t\t     \"Ntot\", \n         \"N_plotB\",\n         \"N_plotD\",\n         \"N_plotF\",\n\t   \"falljuvrelsurv_mo\", \n    \t\t\"falladrelsurv_mo\",\n    \t\t\"springjuvrelsurv_mo\", \n   \t\t\"springadrelsurv_mo\"\n)   \n\n\nsetwd(BUGSDir)\n\nMod <- bugs(data=Data, inits=Inits, parameters.to.save=Par,  #  run BUGS model\n                   model.file=model.file, n.chains=2, n.iter=100000,                            # nc / ni / nb / nt\n                   n.burnin=50000, n.thin=5,over.relax = TRUE,bugs.directory=bugs.directory,debug=FALSE)\n                                         \n\nsetwd(BUGSDir)\nsave(Mod,file=sprintf(\"SevModel10_1mnth_newprecip_%s.RData\",Sys.Date()))\n\nnsims = 2500\n\t\t\t\t\t\t\t\t\t   \ncat(paste(\"SCRIPT FINISHED RUNNING SUCCESSFULLY, \",Sys.time(),\", on \",Sys.Date(),\"\\n\",sep=\"\"))\n\n\n\n######################\n#Summary stats for table\nsetwd(BUGSDir)\nload(\"SevModel10_1mnth_newprecip_2016-07-16.RData\")\n\n#Phi\nmean(Mod$sims.list$phi)\nquantile(Mod$sims.list$phi ,c(0.025,0.975))\n\n#Release effect\nmean(Mod$sims.list$relEff)\nquantile(Mod$sims.list$relEff ,c(0.025,0.975))\n\n#Spring Release effect\nmean(Mod$sims.list$springRelEff)\nquantile(Mod$sims.list$springRelEff ,c(0.025,0.975))\n\n#Juvenile effect\nmean(Mod$sims.list$juvEff)\nquantile(Mod$sims.list$juvEff ,c(0.025,0.975))\n\n#Male effect\nmean(Mod$sims.list$maleEff)\nquantile(Mod$sims.list$maleEff ,c(0.025,0.975))\n\n#Precipitation effect\nmean(Mod$sims.list$precipEff)\nquantile(Mod$sims.list$precipEff ,c(0.025,0.975))\n\n#Soil moisture effect\nmean(Mod$sims.list$soilEff)\nquantile(Mod$sims.list$soilEff ,c(0.025,0.975))\n\n#p\nmean(Mod$sims.list$p0)\nquantile(Mod$sims.list$p0 ,c(0.025,0.975))\n\n#Tag retention rate\nmean(Mod$sims.list$tagRetentionRate)\nquantile(Mod$sims.list$tagRetentionRate ,c(0.025,0.975))\n\n#######Derived\n#Residents\n#Adult female:\nmean(Mod$sims.list$femphi)\nquantile(Mod$sims.list$femphi ,c(0.025,0.975))\n\n#Adult male:\nmean(Mod$sims.list$malephi)\nquantile(Mod$sims.list$malephi ,c(0.025,0.975))\n\n#Juvenile:\nmean(Mod$sims.list$juvphi)\nquantile(Mod$sims.list$juvphi ,c(0.025,0.975))\n\n#Releases:\n#Spring:\nmean(Mod$sims.list$springadrelsurv_mo)\nquantile(Mod$sims.list$springadrelsurv_mo, c(0.025,0.975))\n\n#Summer:\nmean(Mod$sims.list$falladrelsurv_mo)\nquantile(Mod$sims.list$falladrelsurv_mo, c(0.025,0.975))\n\n\n##############################################\n############### END OF SCRIPT ################\n",
    "created" : 1478568023220.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1310586063",
    "id" : "EA88CAF3",
    "lastKnownWriteTime" : 1478887633,
    "last_content_update" : 1478887633,
    "path" : "E:/GIT/Sevilleta_pdogs/Sev reintro - BigPlots_script10_oneMonthRelEff.R",
    "project_path" : "Sev reintro - BigPlots_script10_oneMonthRelEff.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}