{
    "collab_server" : "",
    "contents" : "#################### \n#  R script for running pdog *fecundity* analysis for large plots at Sevilleta NWR\n#\nrm(list=ls())\n\nKEVIN = F\nKEVINOFFICE = F\nELIZABETH = F\nELIZABETHOFFICE = T\n\n###################################\n##########  SET WORKING DIRECTORY\n\nif(KEVIN) rootDir <- \"C:\\\\Users\\\\Kevin\\\\Dropbox\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\nif(KEVINOFFICE) rootDir <- \"E:\\\\Dropbox\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\nif(ELIZABETH) rootDir <- \"~/Dropbox/Nevada/Sev Pdog Study/BIG plot study/\"\nif(ELIZABETHOFFICE) rootDir <- \"C:\\\\Users\\\\ehunter\\\\Dropbox\\\\Nevada\\\\Sevilleta\\\\Sev Pdog Study\\\\BIG plot study\\\\\"\n\nScriptDir <- paste(rootDir,\"Rscript\",sep=\"\")\nDataDir <- paste(rootDir,\"Data\",sep=\"\")\nFiguresDir <- paste(rootDir,\"RawFigures\",sep=\"\")\nResultsDir <- paste(rootDir,\"Results\",sep=\"\")\nBUGSDir <- paste(rootDir,\"BUGS\",sep=\"\")\n\nsetwd(DataDir)\n\ngetwd()\n\n  # setwd(BUGSDir)\n  # load(\".RData\")\n\n##################################\n##########  LOAD PACKAGES\n\nlibrary(lubridate)\nlibrary(Hmisc)\nlibrary(vcdExtra)\n\n###################################\n##########   READ IN DATA\n\n#Read in posterior distributions\nsetwd(BUGSDir)\nload(\"SevModel10_1mnth_newprecip_2016-07-16.RData\") \nnames(Mod$sims.list)\nhist(Mod$sims.list$phi0)\n\n###############Everything else - taken from BigPlots_script5, unnecessary parts removed\nsetwd(DataDir)\npdog <- read.csv(\"pdog_captures_16ha_9-12-15 AD_KTS_2016.csv\", header=TRUE)  ## KTS: updated with 2015 data and fixed a couple errors in the data\n## EAH: updated with 2016 data through June\n\nnCaptures <- nrow(pdog)\n\n############\n#  Process the capture data \n\nnames(pdog)\npdog$DATE2 <- mdy(pdog$DATE)\npdog$PLOT <- as.character(pdog$PLOT)   \npdog$PTP <- paste(pdog$SEASON,pdog$YEAR,sep=\"\")   # Primary trapping period\n\nunique(pdog$PTP)\n\npdog <- subset(pdog,!PLOT==\"G\")    # remove plot G for now (some pdogs released but not surveyed as of 2015)\n\npdog <- subset(pdog,!TRAPDAY%in%c(4,5))    # remove observations on \"experimental\" fourth and fifth capture days\n\n#pdog$TRAPDAY\n\n###############################\n####### DEFINE \"PERIOD\" FOR THIS STUDY\n\n# Note: some plots were trapped at different times within the same season- so trap day 1 isn't necessarily always the same date...\n\nsetwd(DataDir)\nfilename <- \"PeriodDefinition.csv\"\nPeriodDef <- read.csv(filename)\n\nPeriodDef$StartDate <- mdy(PeriodDef$Start)\nPeriodDef$EndDate <- mdy(PeriodDef$End)\n#PeriodDef$Interval <- new_interval(PeriodDef$StartDate, PeriodDef$EndDate)\n\nnPeriods <- nrow(PeriodDef)\n\n  #####  DETERMINE PERIOD BETWEEN EACH PRIMARY SURVEY (periods among which population is open)\n\n ## convert to datetime object\npdate <- mdy(PeriodDef$Median)\n\n ## \ncounter=1\nintervals <- numeric(nPeriods-1)\nfor(i in 2:nPeriods){\n  intervals[counter]=as.numeric(difftime(pdate[i],pdate[i-1],units=\"days\"))/365\n  counter =counter+1\n}\n\nPeriodDef$Intervals <- c(intervals,NA)\n\n\n###############################\n#######  READ IN ENV CONDITIONS- PRECIP AND SOIL MOISTURE\n#Using the precip interval that would affect that period\n#For summer periods: May-Oct\n#For spring periods: Nov-Apr\n\nsetwd(DataDir)\nPrecipPeriodDef <- read.csv(filename)\n\nPrecipPeriodDef$StartDate <- mdy(PrecipPeriodDef$Start)\nPrecipPeriodDef$EndDate <- mdy(PrecipPeriodDef$End)\n\nenvCond_df <- read.csv(\"Month_sums_50 -sev 2010-2016_ppt.csv\",header=T) #Now includes 2016 through May\nnames(envCond_df)\n\n  ## add a \"Date\" field\ntemp <- paste(envCond_df$mon,1,envCond_df$year,sep=\"/\")\nenvCond_df$Date <- mdy(temp)\n\n#########\n#  summarize environmental conditions by period\n##JUST PRECIP and SOILH2O\nenvCond_df <- envCond_df[,c(1,2,6,12,13)]\nenvCondNames <- names(envCond_df)\n\nnewline <- envCond_df[1,-which(envCondNames%in%c(\"Date\",\"mon\"))]\nnames(newline)[1] <- \"Period\"\n\nenvCond <- newline[-1,]\n\np=1\nfor(p in 1:nPeriods){\n  ndx <- which((envCond_df$Date>=PrecipPeriodDef$StartDate[p])&(envCond_df$Date<PrecipPeriodDef$EndDate[p]))\n  temp <- newline\n  temp[1,1] <- as.character(PrecipPeriodDef$Period[p])\n  i=2\n  for(i in 2:ncol(temp)){\n    colname <- names(temp)[i]\n    ndx2 <- which(names(envCond_df)==colname)\n    temp[1,i] <- mean(envCond_df[ndx,ndx2])\n  }\n  envCond <- rbind(envCond,temp)\n}\n\nprecip <- envCond$ppt\n\n       ## and soil moisture data...\n\nsoilH2O <- envCond$sH2O\n\n\n\n###################################\n   ####        DEVELOP UNIQUE ID VAR (\"indiv\")\n   ####  KTS 11/17/15: made this more thorough- now record number of tags and type of tags for each individual\n\n\npdog$TagR <- as.character(pdog$RIGHTTAG)      \npdog$TagL <- as.character(pdog$LEFTTAG)\npdog$PIT.TAG <- as.character(pdog$PITTAG)\n\nndx <- which(pdog$TagR==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$TagR[ndx] <- NA \nndx <- which(pdog$TagL==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$TagL[ndx] <- NA \nndx <- which(pdog$PIT.TAG==\"\")                # change \"\" to NA\nif(length(ndx)>0) pdog$PIT.TAG[ndx] <- NA \n\n\n### new strategy: \n       # first make a list with all single tags \n       # then loop through this vector\n           # IF this ID was ever observed on the same individual as another ID later in the list, \n           # THEN remove that other ID from the list and associate it with the ID in question \n             \n### NOTE: this takes a long time, totally inefficient, but whatever! \n\nuniqueR <- unique(pdog$TagR)\nuniqueR <- uniqueR[!is.na(uniqueR)]\nuniqueL <- unique(pdog$TagL)\nuniqueL <- uniqueL[!is.na(uniqueL)]\nuniquePIT <- unique(pdog$PIT.TAG)\nuniquePIT <- uniquePIT[!is.na(uniquePIT)]\n\nfreeIDs <- c(uniqueL,uniqueR,uniquePIT)  # all unique ID tags\nusedIDs <- numeric(0)\n\nindivList <- list()\nIDarray <- with(pdog,cbind(TagL,TagR,PIT.TAG) )\n\ncounter=1\nt=1\nfor(t in 1:length(freeIDs)){      #loop through all ID tags\n  thisID <- freeIDs[t]\n  if(!thisID%in%usedIDs){   # if this tag hasn't been used before\n    indivList[[counter]] <- thisID    # this must be a new individual \n    usedIDs <- c(usedIDs,thisID)\n    temp <- IDarray[apply(IDarray,1,function(t) thisID%in%t),]   # observations involving this tag\n    temp <- unique(as.vector(temp))\n    temp <- temp[!is.na(temp)]\n    temp <- temp[temp!=thisID]\n    if(length(temp)>0){\n      indivList[[counter]] <- c(indivList[[counter]],temp)  # add all other associated IDs\n      usedIDs <- c(usedIDs,temp)\n\n      while(length(temp)>0){  # go through the other IDs- make sure that these IDs are not associated with other IDs\n        thisID2 <- temp[1]     #take the first element of temp\n        temp2 <- IDarray[apply(IDarray,1,function(t) thisID2%in%t),]\n        temp2 <- unique(as.vector(temp2))\n        temp2 <- temp2[!is.na(temp2)]\n        temp2 <- temp2[!temp2%in%usedIDs]\n        indivList[[counter]] <- c(indivList[[counter]],temp2)    # add any new ID tags associated with this individual\n        usedIDs <- c(usedIDs,temp2)\n        temp<-temp[-1]\n      }  \n    }  \n    counter <- counter + 1 \n  }\n}\n\n\n #####  Good- this seems to work...\n\n#######################################\n### NOW: make a new \"indiv\" field... \n\n### NOTE: again, this takes a long time, but F#@# it :) \n\npdog$indiv <- 0\n\nnan <- length(indivList)\n\nnrow(IDarray)     # temp\nnrow(pdog)\n\n\nerrcheck <- numeric(0)   # which individual IDs, if any, are associated with multiple individuals (error check)\nnoobsndx <- numeric(0)   # which observations are associated with no ID at all??\n\ni=32\nfor(i in 1:nrow(pdog)){\n  tempID <- IDarray[i,]\n  tempID <- unique(as.vector(tempID))\n  tempID <- tempID[!is.na(tempID)]\n  tempID <- tempID[1]  # just pick the first of the IDs...\n\n  temp2 <- (1:nan)[sapply(indivList,function(t) tempID%in%t)]   # which individual is this??\n\n  if(length(temp2)>1) errcheck <- c(errcheck,i)   # if this corresponds to more than one individual, there is a problem!!\n  if(length(temp2)==0) noobsndx <- c(noobsndx,i)\n  pdog$indiv[i] <- ifelse(length(temp2)==1, temp2, NA)  \n}\n\nerrcheck   # Good- no ambiguous identifications\n\nnoobsndx    # 9 captures with no IDs \n\npdog[noobsndx,]   # checks out\n\n##### NOW: remove any individuals that had no ID\n\npdog <- pdog[-noobsndx,]\n\npdog$indiv    # looks OK\n\n\n#### NOW: generate capture histories as a list- one dataframe of observations per individual (CHList)\n\nuniqueNames <- unique(pdog$indiv)\nnan <- length(uniqueNames)\ni=1122\nCHList <- list()   \nfor(i in 1:nan){        # remember to sort by date\n  eval(parse(text=sprintf(\"CHList$indiv%s <- subset(pdog,indiv==uniqueNames[i])\",uniqueNames[i])))\n  eval(parse(text=sprintf(\"CHList$indiv%s <- CHList$indiv%s[order(CHList$indiv%s$DATE2),]\",uniqueNames[i],uniqueNames[i],uniqueNames[i])))\n}\n\n  \n####################################\n##########  SUMMARY DATA (global: suffix \"G\")\n\nnames(pdog)\n\nnobsG <- nrow(pdog)       # 3272 observations\n\nnindG <- length(unique(pdog$indiv))     # 2505 individuals \n\nrealindG <- unique(pdog$indiv)  \n\nnyearsG <- length(unique(pdog$YEAR))     # 6 years\n\nrealyearsG <- sort(unique(pdog$YEAR))\n\nnperiodsG <- length(unique(pdog$PTP))    # 10 primary trapping periods\n\nrealperiodsG <- unique(pdog$PTP)\n\nnplotsG <- length(unique(pdog$PLOT))     # 3 plots\n\nrealplotsG <- as.character(unique(pdog$PLOT)) \n\nndatesG <- length(unique(pdog$DATE))     # 73 survey occasions / release events\n\nrealsurveydatesG <- format(sort(unique(pdog$DATE2[which(!is.na(pdog$TRAPDAY))])),format=\"%m/%d/%Y\")\n\nnsurveysG <- length(realsurveydatesG)   # 38 trapping surveys\n\nrealreleasedatesG <- format(sort(unique(pdog$DATE2[which(is.na(pdog$TRAPDAY))])),format=\"%m/%d/%Y\")\n\nnreleasesG <- length(realreleasedatesG)   # 31 release dates\n\nrealdatesG <- format(sort(unique(pdog$DATE2)),format=\"%m/%d/%Y\")\n\nrealperiodyearsG <- as.numeric(na.omit(as.numeric(unlist(strsplit(unlist(realperiodsG), \"[^0-9]+\")))))\n\n   # look at num caps each year by plot\n\ntable(pdog$PLOT,pdog$YEAR)   \n\npdog$PTP2 <- factor(pdog$PTP,levels=realperiodsG)   # make the periods are ordered properly\n\ncaptures <- subset(pdog,!RECAPTYPE==\"RELEASE\")  \n\ntable(captures$PLOT,captures$YEAR)\n\nreleases <- subset(pdog,RECAPTYPE==\"RELEASE\")\n\nsumReleases <- table(releases$PLOT,releases$PTP2)\n\n################################\n############## SUMMARIZE DATA FOR WINBUGS\n\n   ## loop through data and summarize the data for each dimension of interest\n\nns <- nPeriods\nnss <- array(0,dim=c(nPeriods))   # number of surveys (suboccasions)\nnan <- nindG   # number of animals \nnames <- realindG  #  list()\n\ny=4\nfor(y in 1:nPeriods){\n  ndx <- which((pdog$PTP==realperiodsG[y])&(!is.na(pdog$TRAPDAY)))     \n  nss[y] <- length(unique(pdog$TRAPDAY[ndx]))\n}\nnss[1] <- 1    # allow the first season to have a dummy trapping event (these are all releases... )\n\nmaxnan <- max(nan)\nmaxnss <- max(nss)      # max of 3 suboccasions... \n\n##########################\n#######       MAKE CAPTURE HISTORY DATA\n######## INITIALIZE DATA ARRAYS\n\ncaphist <- array(0,dim=c(maxnan,nperiodsG,maxnss))     # Master 3-D capture history array\ncaphist_2D <- array(0,dim=c(maxnan,nperiodsG))\nNMarks <- array(NA,dim=c(maxnan,nperiodsG))     # choose the min number of marks in each PTP\nLeftEarTag <- array(NA,dim=c(maxnan,nperiodsG))\nRightEarTag <- array(NA,dim=c(maxnan,nperiodsG))\n\nReleased <- array(0,dim=c(maxnan,nperiodsG))    # if release happens after trapping, code as \"1\" in final suboccasion. If released before trapping, put \"1\" in initial suboccasion.\nSpringRelease <- array(0,dim=c(maxnan,nperiodsG)) # NOTE: actually, releases ALWAYS happened after the final trapping event (this is good!)\n #Juvenile <- array(0,dim=c(maxnan,nperiodsG))\nPITTag <- array(0,dim=c(maxnan,nperiodsG))     # if it has a pit tag, can't lose tags\nAddLeftTag <- array(0,dim=c(maxnan,nperiodsG))\nAddRightTag <- array(0,dim=c(maxnan,nperiodsG)) \n\nfirsts <- numeric(maxnan)\nfirst2 <- numeric(maxnan)\n\naddTagNdx <- character(0)   # observations where tag was added...\n  \n\nind=285#2510#2327#285#1122#1#\nfor(ind in 1:nan){\n  df <- CHList[[ind]] \n              # make sure to sort by date!\n  df <- df[order(df$DATE2),]\n  tags <- with(df,cbind(TagL,TagR,PIT.TAG))\n                                                         ### ensure that once it has a pit tag, it always has that pit tag... \n  pitpresent <- !is.na(tags[,3])   # is there a PIT tag?\n  firstpit <- ifelse(any(pitpresent),which(pitpresent)[1],NA)\n  if(!is.na(firstpit)) tags[min(nrow(df),(firstpit+1)):nrow(df),3] <- tags[firstpit,3]    # make sure that pit tag is not lost... since pit tags cant be lost in this model\n\n  df$nMarks <-  apply(tags,1,function(t) length(t[!is.na(t)])) \n  \n  obs <- 1\n  for(obs in 1:nrow(df)){   # loop through by observation.. \n    thisObs <- df[obs,]\n    thisTags <- tags[obs,]\n    thisPeriod <- which(PeriodDef$Period==thisObs$PTP)\n    thisSub <- ifelse(!is.na(thisObs$TRAPDAY),thisObs$TRAPDAY,max(nss[thisPeriod]))    # if it's just released, put it at the last suboccasion\n\n    if(obs==1){    # if this is the first capture\n      firsts[ind] <- thisPeriod            # record period of first capture\n      first2[ind] <- thisSub\n    }\n\n    if((!is.na(firstpit))&(obs==firstpit)){  # if has pit and this is the first observation with pit tag\n      PITTag[ind,thisPeriod:nPeriods] <- 1      # then we assume this individual has a pit tag forever, as long as it is alive. can't lose this mark\n    }\n      \n    caphist[ind,thisPeriod,thisSub] <- 1                              # captured this suboccasion?\n    caphist_2D[ind,thisPeriod] <- 1                                   # capture this period? (standard 2D capture history)\n\n    if(thisObs$RECAPTYPE==\"RELEASE\"){\n      Released[ind,thisPeriod] <- 1    # released this period?   \n\t  if(month(thisObs$DATE2)%in%c(4,5,6)) SpringRelease[ind,thisPeriod] <- 1                             # is it a spring release?\n\t}\n\n    NMarks[ind,thisPeriod] <- df$nMarks[obs]  # number of tags observed on this individual\n    LeftEarTag[ind,thisPeriod] <- ifelse(!is.na(tags[,\"TagL\"][obs]),1,0) \n    RightEarTag[ind,thisPeriod] <- ifelse(!is.na(tags[,\"TagR\"][obs]),1,0)   \n    tagsadded <- (!is.na(thisTags))&((!thisTags==tags[max(1,obs-1),])|(is.na(tags[max(1,obs-1),])))\n    AddLeftTag[ind,thisPeriod] <- ifelse(tagsadded[1],1,0)\n    AddRightTag[ind,thisPeriod] <- ifelse(tagsadded[2],1,0)\n    if(any(tagsadded)) addTagNdx <- c(addTagNdx,sprintf(\"ind%s_obs%s\",ind,obs))\n  }  \n}\n\n   # make sure once indiv has PIT, it is not lost... \ntail(PITTag,500)\n\n\n##############################\n##        STORE SEX AND AGE FOR EACH INDIVIDUAL\n\nisMale <- numeric(nan)\n\nfor(i in 1:nan){\n  ndx <- which(pdog$indiv==names[i])\n  sexvec <- pdog$SEX[ndx]\n  sexvec <- sexvec[which(!is.na(sexvec))]\n  sex <- as.character(sexvec[length(sexvec)])    # final determined sex is the true sex...\n  isMale[i] <- ifelse(length(sex>0),ifelse(sex==\"M\",1,0),0)\n   #  pdogT[ndx,]\n}\n\n \nisJuv  <- array(1,dim=c(nan,nperiodsG))\n\ni=1   #363\np=firsts[i]\nfor(i in 1:nan){\n  firstyear <- realperiodyearsG[firsts[i]]\n  for(p in firsts[i]:nperiodsG){\n    if(realperiodyearsG[p]==firstyear){   # if within the first year of capture\n      ndx <- which((pdog$indiv==names[i]) &\n                 (pdog$YEAR==firstyear) )\n      if(length(ndx)>0){\n        tempage <- as.character(pdog$AGE[ndx])[1]\n        isJuv[i,p] <- ifelse(tempage==\"J\",1,0)\n      }\n    } else{\n      isJuv[i,p] <- 0\n    } \n  }\n}\n\nisJuv <- apply(isJuv,c(1,2),function(t) ifelse(is.na(t),0,t))\n\ntail(isJuv,500)\n\n\n########################################\n#########    standardize covariates\n\nmeanlogprecip <- mean(log(precip))             # standardize precip variable\nsdlogprecip <- sd(log(precip))\nprecip_std <- (log(precip)-meanlogprecip)/sdlogprecip\n\nmeanlogsoil <- mean(log(soilH2O))             # standardize soil variable\nsdlogsoil <- sd(log(soilH2O))\nsoil_std <- (log(soilH2O)-meanlogsoil)/sdlogsoil\n\n\n######################\n#Input data for simulation (releases):\n#Collapse \"releases\" into table divided up by age, sex (just females), year, and season\nReleasedAge <- table(releases$AGE, releases$YEAR, releases$SEX, releases$SEASON, exclude=c(\"\", \"M\"), dnn=c(\"Age\", \"Year\", \"Sex\", \"Season\"))\nReleasedAge <- as.data.frame(collapse.table(ReleasedAge, Sex=c(\"F\", \"F\", \"F\", \"F\", \"F\"), Age=c(\"A\", \"J\", \"J\")))\nReleasedAge$Year <- as.numeric(as.character(ReleasedAge$Year))\nReleasedAge <- rbind(ReleasedAge, c(as.character(\"A\"), as.numeric(2014), as.character(\"F\"), as.character(\"SPRING\"), as.numeric(0)), \n\tc(as.character(\"J\"), as.numeric(2014), as.character(\"F\"), as.character(\"SPRING\"), as.numeric(0)), \n\tc(as.character(\"A\"), as.numeric(2014), as.character(\"F\"), as.character(\"SUMMER\"), as.numeric(0)), \n\tc(as.character(\"J\"), as.numeric(2014), as.character(\"F\"), as.character(\"SUMMER\"), as.numeric(0)),\n\tc(as.character(\"A\"), as.numeric(2016), as.character(\"F\"), as.character(\"SPRING\"), as.numeric(0)), \n\tc(as.character(\"J\"), as.numeric(2016), as.character(\"F\"), as.character(\"SPRING\"), as.numeric(0)))\nReleasedAge$Year <- as.numeric(ReleasedAge$Year); ReleasedAge$Freq <- as.numeric(ReleasedAge$Freq)\nReleasedAge <- ReleasedAge[order(ReleasedAge$Year),]\nnames(ReleasedAge) <- c(\"Age\", \"Year\", \"Sex\", \"Season\", \"N\")\n\n#Need \"ReleasedSpring\" and \"ReleasedSummer\" dataframes, separating out the females released in spring in 2012 and 2013\nReleasedSpring <- matrix(c(seq(2010,2016, length=nyearsG), rep(0,times=nyearsG)), nrow=nyearsG, ncol=2)\nReleasedSpring <- as.data.frame(ReleasedSpring); names(ReleasedSpring) <- c(\"Year\", \"N\")\nReleasedSpring$N[ReleasedSpring$Year==2012] <- ReleasedAge$N[ReleasedAge$Year==2012 & ReleasedAge$Season==\"SPRING\" & ReleasedAge$Age==\"A\"]\nReleasedSpring$N[ReleasedSpring$Year==2013] <- ReleasedAge$N[ReleasedAge$Year==2013 & ReleasedAge$Season==\"SPRING\" & ReleasedAge$Age==\"A\"]\nReleasedSpring <- as.vector(ReleasedSpring$N)\n\n#Remove spring releases from ReleasedSummer, condense to single season, break into A/J\ntemp <- ReleasedAge\ntemp$N[temp$Year==2012 & temp$Season==\"SPRING\" & temp$Age==\"A\"] <- 0\ntemp$N[temp$Year==2013 & temp$Season==\"SPRING\" & temp$Age==\"A\"] <- 0\ntemp <- aggregate(temp$N, by=list(temp$Year, temp$Age), FUN=sum)\n\nReleasedSummer <- array(0, dim=c(nyearsG, 2)) #2 ages\nReleasedSummer[,1] <- temp[8:14, 3] #Juveniles\nReleasedSummer[,2] <- temp[1:7, 3]  #Adults\n\n##########################\n#Matching projections to proportion \"nativo\"\n#Getting \"nativos\" from pdog dataframe (N in RECAPTYPE)\npdognativos <- pdog[pdog$RECAPTYPE==\"N\",] #104 individuals, but there are 193 individuals with no release date in \"Released\" dataframe?\n#\"Released\" has tag losses, so 104 is the more accurate count.\npdognativost <- table(pdognativos$SEX, pdognativos$YEAR, dnn=c(\"Sex\", \"Year\"))\npdognativost <- collapse.table(pdognativost, Sex=c(\"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"M\"))\n\n#Summary statistic: slope of proportion of nativos in the population over time\n#Need total number of observed pdogs for each year\ntemp <- table(pdog$indiv, pdog$YEAR, pdog$SEX, dnn=c(\"indiv\", \"YEAR\", \"SEX\"))\ntemp <- collapse.table(temp, SEX=c(\"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"M\"))\ntemp2 <- ifelse(temp>0, 1, 0)\ntotalobserved <- t(colSums(temp2))\ntotalobserved <- totalobserved[,3:7]\n\nobsfracnativos <- as.data.frame(pdognativost/totalobserved)\nobsfracnativos$Year <- as.numeric(as.character(obsfracnativos$Year))\nplot(obsfracnativos$Freq ~ obsfracnativos$Year, col=obsfracnativos$Sex, type=\"p\", pch=19, xaxp=c(2012,2015,3), xlab=\"Year\", ylab=\"Fraction Nativos\")\nlegend(\"bottomright\", c(\"Female\", \"Male\"), col=c(\"black\", \"red\"), pch=19)\nobsfracnativosF <- obsfracnativos[obsfracnativos$Sex==\"F\",]  #Just use females for pattern matching\nobsfracnativosF <- obsfracnativosF[1:4,] #Just 2012-2015\nobsfracnativosF <- rbind(obsfracnativosF, c(\"F\", as.numeric(2011), as.numeric(0))) #Add in 2011, which had 0 nativos\nobsfracnativosF$Year <- as.numeric(obsfracnativosF$Year); obsfracnativosF$Freq <- as.numeric(obsfracnativosF$Freq)\nobsfracnativosF <- obsfracnativosF[order(obsfracnativosF$Year),]\n#obsslope <- summary(lm(obsfracnativosF$Freq ~ obsfracnativosF$Year))$coefficients[2,1]\n#This slope indicates number of NEW nativos per year (either juvenile or adult), once they are tagged, no longer a \"nativo\"\n\n#######################\n###Functions:\nnMCMC <- length(Mod$sims.list$phi0)\n\nbasesurvival <- function(draw) {\n\teval(Mod$sims.list$phi0)[draw]\n\t}\n\ncaptureprob <- function(draw) {\n\teval(Mod$sims.list$p0)[draw]\n\t}\n\t\nlogit <- function(p) {\n\tlog(p/(1-p))\n\t}\n\t\nprecipB <- function(draw) {\n\teval(Mod$sims.list$precipEff)[draw]\n\t}\n\t\nsoilB <- function(draw) {\n\teval(Mod$sims.list$soilEff)[draw]\n\t}\n\t\njuvB <- function(draw) {\n\teval(Mod$sims.list$juvEff)[draw]\n\t}\n\t\nrelB <- function(draw) {\n\teval(Mod$sims.list$relEff)[draw]\n\t}\n\t\njuvRelB <- function(draw) {\n\teval(Mod$sims.list$juvRelEff)[draw]\n\t}\n\t\nspringRelB <- function(draw) {\n\teval(Mod$sims.list$springRelEff)[draw]\n\t}\n\njuvsurvival <- function(draw, periods) {\n\ttemp <- logit(basesurvival(draw)) + precipB(draw)*precip_std[periods] + soilB(draw)*soil_std[periods] + juvB(draw)\n\treturn(1/(1 + exp(-1*temp)))\n\t}  \n\t\nadultsurvival <- function(draw, periods) {\n\ttemp <- logit(basesurvival(draw)) + precipB(draw)*precip_std[periods] + soilB(draw)*soil_std[periods]\n\treturn(1/(1 + exp(-1*temp)))\n\t}\n\nsurvivalprob <- function(draw, periods) {\n\ttemp <- c(juvsurvival(draw, periods), adultsurvival(draw, periods))\n\treturn(temp)\n\t}\n\nReljuvsurvival <- function(draw, periods, Season) {\n\ttemp <- logit(basesurvival(draw)) + juvB(draw) + relB(draw) + \n\t\t springRelB(draw)*Season   #+ juvRelB(draw) + precipB(draw)*precip_std[periods] + soilB(draw)*soil_std[periods] \n\treturn(1/(1 + exp(-1*temp)))\n\t} \n\t\nReladultsurvival <- function(draw, periods, Season) {\n\ttemp <- logit(basesurvival(draw)) + relB(draw) + \n\t\tspringRelB(draw)*Season   #+ precipB(draw)*precip_std[periods] + soilB(draw)*soil_std[periods] \n\treturn(1/(1 + exp(-1*temp)))\n\t} \n\nRelsurvivalprob <- function(draw, periods, Season) {\n\ttemp <- c(Reljuvsurvival(draw, periods, Season), Reladultsurvival(draw, periods, Season))\n\treturn(temp)\n\t}\n\t#Season=1 is spring\n\n##############################\n#SIMULATION SCENARIOS\n\nnscenarios <- 500\nnsims <- 10000\nnages <- 2\nnperiods <- c(1, 1, 2, 2, 2, 2) #Number of periods in each year\n\n#Make littersize vector to draw from\nlittersize <- seq(0.01, 2.5, length=nscenarios) #Only a single litter per year, includes underground pup survival rates, prob of pregnancy\n\nff_samp <-sample(seq(0.4, 0.6, length=100), nMCMC, replace=T) #Need to check this range\nfracfem <- function(draw) ff_samp[draw]\n\t\nfertility <- function(draw) {\n\ttemp <- littersize[s] * fracfem(draw)\n\treturn(temp)\n\t}\n\n###############################\n#START SIMULATION\n\nN <- array(0, dim=c(nscenarios, nsims, nyearsG))\nNSpring <- array(0, dim=c(nscenarios, nsims, nyearsG))\nRelSpring <- array(0, dim=c(nscenarios, nsims, nyearsG))\nRelSpringTemp <- array(0, dim=c(nscenarios, nsims, nyearsG))\nRelSummer <- array(0, dim=c(nscenarios, nsims, nages, nyearsG))\nRelSummerTemp <- array(0, dim=c(nscenarios, nsims, nages, nyearsG))\nNativo <- array(0, dim=c(nscenarios, nsims, nyearsG))\nNativoSpring <- array(0, dim=c(nscenarios, nsims, nyearsG))\nfracnativo <- array(0, dim=c(nscenarios,nsims, nyearsG))\nTotN <- array(0, dim=c(nscenarios, nsims, nyearsG))\nCapturedNativos <- array(0, dim=c(nscenarios, nsims, nyearsG))\nreleaseEff_interval <- 1/12 #Release effect only lasts for 1 months\nMCMCsample <- array(0, dim=c(nscenarios, nsims))\n\nfor (s in 1:nscenarios){\nfor (i in 1:nsims){\n\trandnum <- sample(c(1:nMCMC),1)\n\tMCMCsample[s,i] <- randnum\n\tperiods <- 1\nfor (y in 1:(nyearsG-1)){  \n\t#SPRING\n\t\t#Releases:\n\t\t\trel_interval <- min(releaseEff_interval, intervals[periods]) #Release effect is 2 months or shorter, actual interval\n\t\t\tRelsurv <- Relsurvivalprob(draw=randnum, periods=periods, Season=1)^rel_interval\n\t\t\tRelSpringTemp[s,i,y] <- rbinom(1, ReleasedSpring[y], Relsurv[2])\n\t\t\t#Released individuals then survive the rest of the interval at the \"normal\" rate\n\t\t\tsurv_interval <- intervals[periods] - rel_interval\n\t\t\tsurv <- survivalprob(draw=randnum, periods=periods)^surv_interval \n\t\t\tRelSpring[s,i,y] <- rbinom(1, RelSpringTemp[s,i,y], surv[2])\n\t\t#Survival (of non-released population):\n\t\t\tif (y > 1) {  #This only occurs after the first year\n\t\t\tsurv <- survivalprob(draw=randnum, periods=periods)^intervals[periods]  \n\t\t\tNSpring[s,i,y] <- sum(rbinom(1, N[s,i,y-1], surv[2]),\n\t\t\t\t\t\tRelSpring[s,i,y],  #Add in released, survived adults\n\t\t\t\t\t\tround(rbinom(1, Nativo[s,i,y-1], surv[2])*(captureprob(randnum)))) #Captured nativos are marked\n\t\t\tNativoSpring[s,i,y] <- round(rbinom(1, Nativo[s,i,y-1], surv[2])*(1-captureprob(randnum))) \n\t\t\t}\n\t\tif (nperiods[y] == 2){periods <- periods + 1}\n\t\t\t\n\n\t#REPRODUCTION\n\t\t#Adult N (and nativos) produce offspring as a function of fecundity parameters \n\t\t\tNoffspring <- round(sum(NSpring[s,i,y], NativoSpring[s,i,y]) * fertility(randnum))\n\n\t#SUMMER\n\t\t#Releases:\n\t\tfor (a in 1:nages){\n\t\t\trel_interval <- min(releaseEff_interval, intervals[periods]) #Release effect is 2 months or shorter, actual interval\n\t\t\tRelsurv <- Relsurvivalprob(draw=randnum, periods=periods, Season=0)^intervals[periods]\n\t\t\tRelSummerTemp[s,i,a,y] <- rbinom(1, ReleasedSummer[y,a], Relsurv[a])\n\t\t\t#Released individuals then survive the rest of the interval at the \"normal\" rate\n\t\t\tsurv_interval <- intervals[periods] - rel_interval\n\t\t\tsurv <- survivalprob(draw=randnum, periods=periods)^surv_interval \n\t\t\tRelSummer[s,i,a,y] <- rbinom(1, RelSummerTemp[s,i,a,y], surv[a])\n\t\t}\n\t\t#Survival:\n\t\t\tsurv <- survivalprob(draw=randnum, periods=periods)^intervals[periods] \n\t\t\tN[s,i,y] <- sum(rbinom(1, NSpring[s,i,y], surv[2]), #Survival of adult to adult\n\t\t\t\t\t\tsum(RelSummer[s,i,,y]), #Add in the survived, released summer females (summed juv and adult)\n\t\t\t\t\t\tround(rbinom(1, Noffspring, surv[1])*(captureprob(randnum))), #Captured nativos are marked\n\t\t\t\t\t\tround(rbinom(1, NativoSpring[s,i,y], surv[2])*(captureprob(randnum)))) \n\t\t#Female nativos survive, and those that are not captured stay \"nativo\"\n\t\t\tNativo[s,i,y] <- sum(round(rbinom(1, Noffspring, surv[1])*(1-captureprob(randnum))), #Survival of juv to adult \n\t\t\t\t\t\tround(rbinom(1, NativoSpring[s,i,y], surv[2])*(1-captureprob(randnum)))) #Survival of adult to adult \n\t\t#Captured nativos for pattern matching\n\t\t\tCapturedNativos[s,i,y] <- sum(round(rbinom(1, Nativo[s,i,y], surv[2])*(captureprob(randnum))),\n\t\t\t\t\t\tround(rbinom(1, Noffspring, surv[1])*(captureprob(randnum))))\n\t\tperiods <- periods + 1\n\n\t#Get the fraction nativo for each year (need to sum captured and uncaptured nativos) out of total population size\n\t\tfracnativo[s,i,y] <- sum(Nativo[s,i,y], CapturedNativos[s,i,y]) / sum(N[s,i,y], Nativo[s,i,y])\n\t\tTotN[s,i,y] <- sum(N[s,i,y], Nativo[s,i,y])\n}\n}\n}\n\n#Find the fracnativo's that are within 5% of obsfracnativosF for each year 2012-2015\ntemp.12 <- fracnativo[,,3] <= (0.05*obsfracnativosF$Freq[2] + obsfracnativosF$Freq[2]) & fracnativo[,,3] >= (obsfracnativosF$Freq[2] - 0.05*obsfracnativosF$Freq[2]) \ntemp.13 <- fracnativo[,,4] <= (0.05*obsfracnativosF$Freq[3] + obsfracnativosF$Freq[3]) & fracnativo[,,4] >= (obsfracnativosF$Freq[3] - 0.05*obsfracnativosF$Freq[3]) \ntemp.14 <- fracnativo[,,5] <= (0.05*obsfracnativosF$Freq[4] + obsfracnativosF$Freq[4]) & fracnativo[,,5] >= (obsfracnativosF$Freq[4] - 0.05*obsfracnativosF$Freq[4]) \ntemp.15 <- fracnativo[,,6] <= (0.05*obsfracnativosF$Freq[5] + obsfracnativosF$Freq[5]) & fracnativo[,,6] >= (obsfracnativosF$Freq[5] - 0.05*obsfracnativosF$Freq[5]) \ntemp.rows <- row(fracnativo[,,3])\ntemp.12.2 <- temp.rows[which(temp.12==TRUE)]\ntemp.13.2 <- temp.rows[which(temp.13==TRUE)]\ntemp.14.2 <- temp.rows[which(temp.14==TRUE)]\ntemp.15.2 <- temp.rows[which(temp.15==TRUE)]\n#Sample from each year (so that no year is overrepresented).  \n#Doing this because practically impossible to get a single fertility that matches all three years.\nsamps <- min(c(length(temp.12.2), length(temp.13.2), length(temp.14.2), length(temp.15.2)))\nsamp.12 <- sample(1:length(temp.12.2), size=samps)\ntemp.12.3 <- temp.12.2[samp.12]\nsamp.13 <- sample(1:length(temp.13.2), size=samps)\ntemp.13.3 <- temp.13.2[samp.13]\nsamp.14 <- sample(1:length(temp.14.2), size=samps)\ntemp.14.3 <- temp.14.2[samp.14]\nsamp.15 <- sample(1:length(temp.15.2), size=samps)\ntemp.15.3 <- temp.15.2[samp.15]\nfertoutput <- littersize[c(temp.12.3, temp.13.3, temp.14.3, temp.15.3)]\nhist(fertoutput, breaks=20)\nquantile(fertoutput, probs=c(0.025, 0.975))\n\nplot(density(littersize[temp.12.3]), xlim=c(0,1))\nlines(density(littersize[temp.13.3]), col=\"red\")\nlines(density(littersize[temp.14.3]), col=\"gray\")\nlines(density(littersize[temp.15.3]), col=\"blue\")\n\n#Get the MCMC run from which each fecundity value was taken - to account for linkage b/w fertility and survival\n#Get the columns\ntemp.cols <- col(fracnativo[,,3])\ncols.12.2 <- temp.cols[which(temp.12==TRUE)]\ncols.12.3 <- cols.12.2[samp.12]\ncols.13.2 <- temp.cols[which(temp.13==TRUE)]\ncols.13.3 <- cols.13.2[samp.13]\ncols.14.2 <- temp.cols[which(temp.14==TRUE)]\ncols.14.3 <- cols.14.2[samp.14]\ncols.15.2 <- temp.cols[which(temp.15==TRUE)]\ncols.15.3 <- cols.15.2[samp.15]\n\nMCMCfert <- NULL\nfor (i in 1:samps){\n\tx.12 <- MCMCsample[temp.12.3[i], cols.12.3[i]]\n\tx.13 <- MCMCsample[temp.13.3[i], cols.13.3[i]]\n\tx.14 <- MCMCsample[temp.14.3[i], cols.14.3[i]]\n\tx.15 <- MCMCsample[temp.15.3[i], cols.15.3[i]]\n\tMCMCfert <- c(MCMCfert, x.12, x.13, x.14, x.15)\n}\n\n\n###Calculate lambda using popbio package\nlibrary(popbio)\nnsims <- length(MCMCfert)\nlambda <- 0\nfor (i in 1:nsims){\n\trandnum <- MCMCfert[i]\n\tp <- sample(c(1:periods), 1)\n\tm = matrix(c(0, fertoutput[i], juvsurvival(randnum, p), adultsurvival(randnum, p)), nrow=2, ncol=2, byrow=TRUE)\n\tlambda[i] <- lambda(m)\n}\nhist(lambda)\nquantile(lambda, probs=c(0.025, 0.975))\n\nsetwd(BUGSDir)\nsave.image(\"SevModel3_fert_2016-07-16_1mnth_newprecip.RData\")\n\n#Caveat: this is kind of a \"prospective\" lambda in that survival and fertility are not linked,\n#So these are lambdas that we might expect to see in the future under similar conditions\n\n#######\n#Looking at effect of precip on fecundity\nsetwd(BUGSDir)\n#load(\"SevModel3_fert_2016-05-11.RData\")\n#Compare each year to the Nov-April precip starting in the previous year\npN11.A12 <- sum(envCond_df[envCond_df$Date > \"2011-11-01\" & envCond_df$Date < \"2012-05-01\",]$ppt)\npN12.A13 <- sum(envCond_df[envCond_df$Date > \"2012-11-01\" & envCond_df$Date < \"2013-05-01\",]$ppt)\npN13.A14 <- sum(envCond_df[envCond_df$Date > \"2013-11-01\" & envCond_df$Date < \"2014-05-01\",]$ppt)\npN14.A15 <- sum(envCond_df[envCond_df$Date > \"2014-11-01\" & envCond_df$Date < \"2015-05-01\",]$ppt)\n\n\n",
    "created" : 1478568013025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3361679383",
    "id" : "1BDEF485",
    "lastKnownWriteTime" : 1478564018,
    "last_content_update" : 1478564018,
    "path" : "E:/GIT/Sevilleta_pdogs/Sev reintro - BigPlots_Fecundity_script4.R",
    "project_path" : "Sev reintro - BigPlots_Fecundity_script4.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}